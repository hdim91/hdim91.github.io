---
layout: post
title: DataFrame과 List
description: >
    R의 핵심 데이터 타입
excerpt_separator: <!--more-->
---

<!--more-->

DataFrame과 List를 설명하기에 앞서 벡터를 짤게 설명하고자 한다.

# 벡터와 데이터 타입

벡터는 아래와 같이 `c()`로 선언하며, 벡터 안의 요소들은 모두 같은 타입이여야 한다.
```r:
char_var <- c('A','B','C','D') # 문자열 벡터
```
```r:
int_var <- c(1,2,3,4,5) # 숫자 벡터
```
참고로 R에서는 여타 프로그래밍 언어들처럼 숫자를 정수와 실수로 나뉘는데, 이를 `integer` 타입과 `numeric` 타입이라 한다. 파이썬에 친숙한 사람들은 `int`와 `float`을 생각하면 된다.

만약 숫자 벡터 안에 문자열 데이터가 하나라도 들어갈 경우, 모든 숫자들은 문자열로 변환되니 주의해야한다.
```r:
mix_var <- c(1,2,3,4,'D') # 모두 문자열로 변함
```
위와 같이 벡터들을 생성하면, 그 다음에는 생성된 벡터들을 모아 DataFrame을 구축할 수 있게 된다.

# DataFrame

```r:
DF <- data.frame(names = c('하나','둘','셋','넷','다섯'),
                ages = c(1,2,3,4,5))
DF
```
```
  names ages
1  하나    1
2    둘    2
3    셋    3
4    넷    4
5  다섯    5
```

R의 DataFrame을 다룰 때, 행렬 다루듯이 코드를 작성해도 된다는 점이 있다. 예를 들어 `DF$names`는 `DF[,1]`과 같다. `DF`의 첫 칼럼이라는 의미이다.
그리고 각 변수의 특정 조건을 만족하는 요소를 부르고 싶을 때, 예를 들자면 "'둘'이라는 이름을 가진 객체의 나이가 알고싶다"라고 한다면, 아래와 같이 코딩이 가능하다.

```r:
DF[DF$names=="둘",]$ages # 또는
DF[DF$names=="둘",2]
```

보는 것처럼 R의 데이터프레임은 데이터 분석을 행렬의 관점에서 접근할 때 상당한 편의성과 자율성을 제공한다.

# List

리스트는 R 내에서도 특이한 데이터 형태인데, 벡터와 같이 아래처럼 사용할 수 있다.
```r:
mylist <- list()
mylist[[1]] <- 1:5 # 1부터 5까지의 숫자 벡터
mylist
```
```
[[1]]
[1] 1 2 3 4 5
```
리스트의 특징 중 하나는 사용자가 원하는 한 확장하는데 상당한 자율성을 보장한다는 것이다.
리스트에 문자열 벡터를 추가해보자.

```r:
mylist[[2]] <- LETTERS[1:5] #알파벳 A~E까지의 벡터
mylist
```
```
[[1]]
[1] 1 2 3 4 5

[[2]]
[1] "A" "B" "C" "D" "E"
```

이제 마지막으로 DataFrame도 추가해보자

```r:
mylist[[3]] <- DF
mylist
```
```
[[1]]
[1] 1 2 3 4 5

[[2]]
[1] "A" "B" "C" "D" "E"

[[3]]
  names ages
1  하나    1
2    둘    2
3    셋    3
4    넷    4
5  다섯    5
```

리스트는 각 차원 안에 사용자가 원하는 형태의 데이터를 얼마든지 넣을 수 있다는 것이 가장 큰 장점이다. 특히 위에서 보았다시피, 리스트 안에는 여러개의 벡터 및 DataFrame을 추가할 수 있다. 이것을 다르게 활용해보면 어떨까?

예를 들어, 오랜 기간 동안 보관되어 온 데이터베이스가 있다고 하자. 그런데 시간이 지나면서 중간중간 관리 방식 및 변수의 설정이 달라졌고, 시게열이 깨졌다고 할 때, 시계열을 복구하려는 과정에서 리스트는 우리에게 높은 편의성을 제공한다. 2010년~2022년까지의 데이터프레임을 각 시간에 따라 버전 순으로 리스트에 저장하고 작업을 실시하게 되면, 우리는 데이터 클리닝 작업시 덜 복잡하게 작업할 수 있다.